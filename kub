#define FUSE_USE_VERSION 31
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>

#include <readline/readline.h>
#include <readline/history.h>

#include "vfs.h"

#define HISTORY_FILE ".kubsh_history"

sig_atomic_t signal_received = 0;

// Handler pour SIGHUP
void sig_handler(int signum) {
    signal_received = signum;
    printf("Configuration reloaded\n");
}

// Fonction pour exécuter un binaire système
void fork_exec(char *full_path, char **argv) {
    int pid = fork();
    if (pid == 0) {
        execv(full_path, argv);
        perror("exec");
        exit(1);
    } else {
        wait(NULL);
    }
}

// Vérifie si le chemin est exécutable
int is_executable(const char *path) {
    return access(path, X_OK) == 0;
}

// Recherche un binaire dans le PATH
char *find_in_path(const char *command) {
    char *path_env = getenv("PATH");
    if (!path_env) return NULL;

    char *paths = strdup(path_env);
    char *dir = strtok(paths, ":");

    while (dir) {
        char full[512];
        snprintf(full, sizeof(full), "%s/%s", dir, command);

        if (is_executable(full)) {
            free(paths);
            return strdup(full);
        }
        dir = strtok(NULL, ":");
    }

    free(paths);
    return NULL;
}

// Fonction interne pour afficher une variable d'environnement
void print_env_var(const char *var_name) {
    if (var_name == NULL || strlen(var_name) == 0) {
        printf("Usage: \\e $VARNAME\n");
        return;
    }

    // Supprime le $ si présent
    if (var_name[0] == '$')
        var_name++;

    const char *value = getenv(var_name);
    if (value == NULL) {
        printf("Variable '%s' not found.\n", var_name);
        return;
    }

    char *copy = strdup(value);
    if (!copy) {
        perror("strdup");
        return;
    }

    printf("%s =\n", var_name);

    // Si la variable contient ':', on l'affiche ligne par ligne
    if (strchr(copy, ':')) {
        char *token = strtok(copy, ":");
        while (token) {
            printf(" - %s\n", token);
            token = strtok(NULL, ":");
        }
    } else {
        printf("%s\n", copy);
    }

    free(copy);
}

// Programme principal
int main() {
    signal(SIGHUP, sig_handler);
    read_history(HISTORY_FILE);

    start_users_vfs("users");

    char *input;

    while (true) {
        input = readline("kubsh> ");

        if (signal_received) {
            signal_received = 0;
            continue;
        }

        if (!input)
            break;

        add_history(input);

        // Quitter le shell
        if (!strcmp(input, "\\q")) {
            free(input);
            break;
        }

        // Afficher une variable d'environnement
        else if (strncmp(input, "\\e ", 3) == 0) {
            print_env_var(input + 3);
        }

        // Exécuter une commande système
        else {
            char *argv[11];
            int argc = 0;
            char *token = strtok(input, " ");

            while (token && argc < 10) {
                argv[argc++] = token;
                token = strtok(NULL, " ");
            }
            argv[argc] = NULL;

            char *cmd_path = find_in_path(argv[0]);

            if (cmd_path) {
                fork_exec(cmd_path, argv);
                free(cmd_path);
            } else {
                printf("%s: command not found\n", argv[0]);
            }
        }

        free(input);
    }

    write_history(HISTORY_FILE);
    stop_users_vfs();

    return 0;
}
